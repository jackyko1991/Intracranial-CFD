// -*- C++ -*-
// File generated by PyFoam - sorry for the ugliness

FoamFile
{
 version 2.0;
 format ascii;
 class dictionary;
 object blockMeshDict;
}

castellatedMesh yes;
snap yes;
addLayers yes;
geometry
{
  domain_capped.stl
  {
    type triSurfaceMesh;
    name Geometry;
    scale 0.001;
    regions
    {
      boundary_0
      {
        name boundary_0;
      }
      boundary_1
      {
        name boundary_1;
      }
      boundary_2
      {
        name boundary_2;
      }
      boundary_3
      {
        name boundary_3;
      }
      boundary_4
      {
        name boundary_4;
      }
      boundary_5
      {
        name boundary_5;
      }
      vessel
      {
        name vessel;
      }
    }
  }
} 	// Settings for the castellatedMesh generation

castellatedMeshControls
{
  maxLocalCells 15000000;
  maxGlobalCells 20000000; 	// Refinement parameters// ---------------------// If local number of cells is >= maxLocalCells on any processor, switches from refinements followed by balancing (current method) to (weighted) // balancing before refinement.// Overall cell limit (approximately). Refinement will stop immediately upon reaching this number so a refinement level might not complete.// Note that this is the number of cells before removing the part which is not 'visible' from the keepPoint. The final number of cells might actually be a lot less// The surface refinement loop might spend lots of iterations refining just a few cells This setting will cause refinement to stop if <= minimumRefine// are selected for refinement. Note: it will at least do one iteration (unless the number of cells to refine is 0)
  minRefinementCells 0; 	// Allow a certain level of imbalance during refining (since balancing is quite expensive)// Expressed as fraction of perfect balance (= overall number of cells/ nProcs). 0 = balance always
  maxLoadUnbalance 0.1; 	// Number of buffer layers between different levels.// 1 means normal 2:1 refinement restriction, larger means slower refinement
  nCellsBetweenLevels 3; 	// Explicit feature edge refinement// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~// Specifies a level for any cell intersected by explicitly provided edges// This is a featureEdgeMesh, read from constant/triSurface for now.// Specify 'levels' in the same way as the 'distance' mode in the refinementRegions (see below). The old specification//		level 2;// is equivalent to //		levels ((0 2));
  features
    (

      {
        file "surface_capped.eMesh";
        levels
          (

            (
              4
              4
            )
          );

      }
    ); 	// Surface based refinement// ~~~~~~~~~~~~~~~~~~~~~~~~// Specifies two levels for every surface. The first is the minimum level,// every cell intersecting a surface gets refined up to the minimum level.// The second level is the maximum level. Cells that 'see' multiple intersections where the intersections make an angle > resolveFeatureAngle// get refined up to the maximum level.// All surfaces defined in the geometry subdirectory must be listed here.// List of the surfaces, which need to be listed in in the boundary files in constant/polyMesh/boundar
  refinementSurfaces
  {
    Geometry
    {
      level
        (
          1
          1
        );
      regions
      {
        boundary_0
        {
          level (4 4);
          patchInfo
          {
            type patch;
          }
        }
        boundary_1
        {
          level (4 4);
          patchInfo
          {
            type patch;
          }
        }
        boundary_2
        {
          level (4 4);
          patchInfo
          {
            type patch;
          }
        }
        boundary_3
        {
          level (4 4);
          patchInfo
          {
            type patch;
          }
        }
        boundary_4
        {
          level (4 4);
          patchInfo
          {
            type patch;
          }
        }
        boundary_5
        {
          level (4 4);
          patchInfo
          {
            type patch;
          }
        }
        vessel
        {
          level (3 4);
          patchInfo
          {
            type wall;
          }
        }
      }
    }
  } 	// Feature angle:// -used if min and max refinement level of a surface differ// -used if feature snapping (see snapControls below) is used
  resolveFeatureAngle 30; 	// Region-wise refinement// ~~~~~~~~~~~~~~~~~~~~~~// Specifies refinement level for cells in relation to a surface. One of three modes// - distance. 'levels' specifies per distance to the surface the want refinement level. The distances need to be specified in increasing order// - inside. 'levels' is only one entry and only the level is used. All cells inside the surface get refined up to the level. // The surface needs to be closed for this to be possible.// - outside. Same but cells outside
  refinementRegions
  {
    refinementCylinder
    {
      mode inside;
      levels
        (

          (
            1000000000000000.0
            7
          )
        );
    }
  } 	// Mesh selection// ~~~~~~~~~~~~~~// After refinement patches get added for all refinementSurfaces and all cells intersecting the surfaces get put into these patches.// The section reachable from the locationInMesh is kept.// NOTE: This point should never be on a face, always inside a cell, even after refinement// Recommended this point to be the bifurcation point of the ICA terminus, unit in meter.
  locationInMesh (-0.038842132568359375 -0.04081772232055664 -0.035222236633300784); 	// Whether any faceZones (as specified in the refinementSurfaces) are only on the boundary of corresponding cellZones or also allow free-standing// zone faces. Not used if there are no faceZones.
  allowFreeStandingZoneFaces yes;
} 	// Settings for the snapping

snapControls
{
  nSmoothPatch 3;
  tolerance 1.0; 	// Number of patch smoothing iterations before finding correspondence to surface// Maximum relative distance for points to be attracted by surface.// True distance is this factor times local maximum edge length.// Note: changed (corrected) w.r.t 17x! (17x used 2* tolerance)// Number of mesh displacement relaxation iterations.
  nSolveIter 30; 	//- Maximum number of snapping relaxation iterations. Should stop//  before upon reaching a correct mesh.
  nRelaxIter 5; 	// Number of feature edge snapping iterations.//  Leave out altogether to disable.
  nFeatureSnapIter 10; 	// Detect (geometric) features by sampling the surface (default = false)
  implicitFeatureSnap no;
  explicitFeatureSnap yes;
  multiRegionFeatureSnap no;
} 	// Settings for the layer addition.

addLayersControls
{
  relativeSizes yes;
  expansionRatio 2; 	// Are the thickness parameters below relative to the undistorted// size of the refined cell outside layer (true) or absolute sizes (false).// Expansion factor for layer mesh// Layer thickness specification. This can be specified in one of four ways:// - expansionRatio and finalLayerThickness (cell nearest internal mesh)// - expansionRatio and firstLayerThickness (cell on surface)// - overall thickness and firstLayerThickness// - overall thickness and finalLayerThickness// Expansion factor for layer mesh// Wanted thickness of final added cell layer. // If multiple layers is the thickness of the layer furthest away from the wall.// Relative to undistorted size of cell outside layer.// See relativeSizes parameter. // If relativeSizes this is relative to undistorted size of cell outside layer
  finalLayerThickness 0.3; 	// Wanted thickness of the layer next to the wall. // If relativeSizes this is relative to undistorted size of cell outside layer// finalLayerThickness 0.3;// Wanted overall thickness of layers.// If relativeSizes this is relative to undistorted size of cell outside layer// thickness 0.5;// Minimum thickness of total cell layers. If for any reason layer// cannot be above minThickness do not add layer.// If relativeSizes this is relative to undistorted size of cell outside layer
  minThickness 0.1; 	// Per final patch (so not geometry!) the layer information// Note: This behavior changed after 21x. Any non-mentioned patches now slide unless:// - nSurfaceLayers is explicitly mentioned to be 0.// - angle to nearest surface < slipFeatureAngle (see below)
  layers
  {
    "domain_wall.*"
    {
      nSurfaceLayers 2;
    }
    maxY
    {
      nSurfaceLayers 2;
      expansionRatio 2; 	// Per patch layer data
      finalLayerThickness 0.4;
      minThickness 0.1;
    } 	// Disable any mesh shrinking and layer addition on any point of a patch by setting nSurfaceLayers to 0
    forzenPatches
    {
      nSurfaceLayers 0;
    }
  } 	// If points get not extruded do nGrow layers of connected faces that are// also not grown. This helps convergence of the layer addition process// close to features.// Note: changed (corrected) w.r.t. 17x! (didn't do anything in 17x)
  nGrow 0; 	// Advanced settings// When not to extrude surface. 0 is flat surface, 90 is when two faces// are perpendicular
  featureAngle 60; 	// At non-patched sides allow mesh to slip if extrusion direction makes angle larger than slipFeatureAngle.
  slipFeatureAngle 30; 	// Maximum number of snapping relaxation iterations. Should stop// before upon reaching a correct mesh.
  nRelaxIter 5; 	// Number of smoothing iterations of surface normals
  nSmoothSurfaceNormals 1; 	// Number of smoothing iterations of interior mesh movement direction
  nSmoothNormals 3; 	// Smooth layer thickness over surface patches
  nSmoothThickness 10; 	// Stop layer growth on highly warped cells
  maxFaceThicknessRatio 0.5; 	// Reduce layer growth where ratio thickness to medial// distance is large
  maxThicknessToMedialRatio 0.3; 	// Angle used to pick up medial axis points// Note: changed (corrected) w.r.t. 17x! 90 degrees corresponding to 130 in 17x.
  minMedianAxisAngle 90; 	// Create buffer region for new layer terminations
  nBufferCellsNoExtrude 0; 	// Overall max number of layer addition iterations. The mesher will exit// if it reaches this number of iterations; possibly with an illegal// mesh.
  nLayerIter 50; 	// Max number of iterations after which relaxed meshQuality controls// get used. Up to nRelaxIter it uses the settings in meshQualityControls,// after nRelaxIter it uses the values in meshQualityControls::relaxed.
  nRelaxedIter 20; 	// Additional reporting: if there are just a few faces where there are mesh errors (after adding the layers) print their face centres.// This helps in tracking down problematic mesh ares.// additionalReporting true;
} 	// Generic mesh quality settings. At any undoable phase these determine// where to undo.

meshQualityControls
{
#include "meshQualityDict"
  maxNonOrtho 45; 	// Maximum non-orthogonality allowed. Set to 180 to disable.// Max skewness allowed. Set to <0 to disable.
  maxBoundarySkewness 20;
  maxInternalSkewness 4; 	// Max concaveness allowed. Is angle (in degree) below which concavity is allowed.// 0 is straight face, <0 would be convex face.// Set to 180 to disable
  maxConcave 80; 	// Minimum pyramid volume. Is absolute volume of cell pyramid. Set to a sensible fraction of the smallest cell volume expected.// Set to very negative number (e.g. -1E30) to disable.
  minVol 1e-13; 	// Minimum quality of the tet formed by the face-centre and variable base point minimum decomposition triangles and the cell centre.// This has to be a positive number for tracking to work. Set to very negative (e.g. -1E30) to disable.// <0 = inside out tet,// 0 = flat tet// 1 = regular tet
  minTetQuality 1e-09; 	// Minimum face area. Set to < 0 to disable.
  minArea -1; 	// Minimum face twist. Set to <-1 to disable. Dot product of face normal and face centre triangles normal
  minTwist 0.05; 	// Minimum normalized cell determinant// 1 = hex, <=0 = folded or flattened illegal cell
  minDeterminant 0.001; 	// minFaceWeight (0 -> 0.5)
  minFaceWeight 0.05; 	// minVolRatio (0 -> 1)
  minVolRatio 0.01; 	// must be >0 for Fluent compatibility
  minTriangleTwist -1; 	// If >0: preserve single cells with all points on the surface if the resulting volume after snapping (by approximation) is larger than // minVolCollapseRatio times old volume (i.e. not collapsed to flat cell).// If <0: delete always// minVolCollapseRatio 0.5;// Advanced// Number of error distribution iterations
  nSmoothScale 4; 	// Amount to scale back displacement at error points
  errorReduction 0.75; 	// Optional : some meshing phases allow usage of relaxed rules.// See e.g. addLayersControls::nRelaxedIter.
  relaxed
  {
    maxNonOrtho 45;
  } 	//- Maximum non-orthogonality allowed. Set to 180 to disable.
} 	// Advanced// Flags for optional output// 0 : only write final meshes// 1 : write intermediate meshes// 2 : write volScalarField with cellLevel for postprocessing// 4 : write current intersections as .obj files

debug 0; 	// // Write flags// writeFlags// (//     scalarLevels    // write volScalarField with cellLevel for postprocessing//     layerSets       // write cellSets, faceSets of faces in layer//     layerFields     // write volScalarField for layer coverage// );// Merge tolerance. Is fraction of overall bounding box of initial mesh.// Note: the write tolerance needs to be higher than this.

mergeTolerance 1e-06; 	// ************************************************************************* //

