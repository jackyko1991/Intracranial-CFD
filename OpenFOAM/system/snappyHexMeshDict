/*--------------------------------*- C++ -*----------------------------------*\
| =========                 |                                                 |
| \\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox           |
|  \\    /   O peration     | Version:  2.3.0                                 |
|   \\  /    A nd           | Web:      www.OpenFOAM.org                      |
|    \\/     M anipulation  |                                                 |
\*---------------------------------------------------------------------------*/
FoamFile
{
    version     2.0;
    format      ascii;
    class       dictionary;
    object      blockMeshDict;
}
// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

// Which of the steps to run
castellatedMesh true;
snap true;
addLayers true ;

// Geometry. Define of all surfaces. All surfaces are of class searchableSurface.
// Surfaces are used
// - to specify refinement for any mesh cell intersecting it
// - to specify refinement for any mesh cell inside/ outsider/ near
// - to 'snap' the mesh boundary to the surface
geometry
{
	surface_clipped.stl // STL filename where all the regions are added
	{
		type triSurfaceMesh;
		
		regions
		{
			zone0	// Named region in the STL file
			{
				name vesselWalll; // User-defined patch name. If not provided will be <filename>_<region>
			}
		}

		refinementBox // Geometry to refine. Entities: Box, Cylinder, Sphere, Plane
		{
			type searchableBox;
			min ();
			max ();
		}
	}
}

// Settings for the castellatedMesh generation
castellatedMeshControls
{
	// Refinement parameters
	// ---------------------

	// If local number of cells is >= maxLocalCells on any processor, switches from refinements followed by balancing (current method) to (weighted) 
	// balancing before refinement.
	maxLocalCells 15000000;

	// Overall cell limit (approximately). Refinement will stop immediately upon reaching this number so a refinement level might not complete.
	// Note that this is the number of cells before removing the part which is not 'visible' from the keepPoint. The final number of cells might actually be a lot less
	maxGlobalCells 20000000;

	// The surface refinement loop might spend lots of iterations refining just a few cells This setting will cause refinement to stop if <= minimumRefine
	// are selected for refinement. Note: it will at least do one iteration (unless the number of cells to refine is 0)
	minRefinementCells 0;

	// Allow a certain level of imbalance during refining (since balancing is quite expensive)
	// Expressed as fraction of perfect balance (= overall number of cells/ nProcs). 0 = balance always
	maxLoadUnbalance 0.1;

	// Number of buffer layers between different levels.
	// 1 means normal 2:1 refinement restriction, larger means slower refinement
	nCellsBetweenLevels 3;

	// Explicit feature edge refinement
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	// Specifies a level for any cell intersected by explicitly provided edges
	// This is a featureEdgeMesh, read from constant/triSurface for now.
	// Specify 'levels' in the same way as the 'distance' mode in the refinementRegions (see below). The old specification
	//		level 2;
	// is equivalent to 
	//		levels ((0 2));
	features
	(
		{
			file "surfaceClipped.eMesh";
			levels ((4 4))
		}	
	)

	// Surface based refinement
	// ~~~~~~~~~~~~~~~~~~~~~~~~

	// Specifies two levels for every surface. The first is the minimum level,
	// every cell intersecting a surface gets refined up to the minimum level.
	// The second level is the maximum level. Cells that 'see' multiple intersections where the intersections make an angle > resolveFeatureAngle
	// get refined up to the maximum level.

	refinementSurfaces
	{
		surface_clipped.stl // STL filename where all the regions are added
		{
			level (6 6);
			regions
			{
				// zone0 // Named region in the STL file
				// {
				// 	level (3 3);
				// 	// Optional specification of patch type (default is wall). No constrain types (cyclic, symmetry) etc. are allowed.
				// 	patchInfo
				// 	{
				// 		type patch;
				// 		inGroups (meshedPatches);
				// 	}
				// }
			}
		}
	}

	// Feature angle:
	// -used if min and max refinement level of a surface differ
	// -used if feature snapping (see snapControls below) is used
	resolveFeatureAngle 30;

	// Region-wise refinement
	// ~~~~~~~~~~~~~~~~~~~~~~

	// Specifies refinement level for cells in relation to a surface. One of three modes
	// - distance. 'levels' specifies per distance to the surface the want refinement level. The distances need to be specified in increasing order
	// - inside. 'levels' is only one entry and only the level is used. All cells inside the surface get refined up to the level. 
	// The surface needs to be closed for this to be possible.
	// - outside. Same but cells outside

	refinementRegions
	{
		refinementCylinder
		{
			mode inside;
			levels ((1E15 7));
		}
	}

	// Mesh selection
	// ~~~~~~~~~~~~~~

	// After refinement patches get added fro all refinementSurfaces and all cells intersecting the surfaces get put into these patches.
	// The section reachable from the locationInMesh is kept.
	// NOTE: This point should never be on a face, always inside a cell, even after refinement
	locationInMesh (0.05 0.03 0.0175);

	// Whether any faceZones (as specified in the refinementSurfaces) are only on the boundary of corresponding cellZones or also allow free-standing
	// zone faces. Not used if there are no faceZones.
	allowFreeStandingZoneFaces true;
};

// Settings for the snapping
snapControls
{
	// Number of patch smoothing iterations before finding correspondence to surface
	nSmoothPatch 3;

	// Maximum relative distance for points to be attracted by surface.
	// True distance is this factor times local maximum edge length.
	// Note: changed (corrected) w.r.t 17x! (17x used 2* tolerance)
	tolerance 1.0;

	// Number 
}
